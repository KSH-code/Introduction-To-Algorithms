# MIT OPENCOURSEWARE 를 읽고 쎄타 표기법을 조금 더 확실하게 이해해야 된다.
### 함수의 증가
2장에서 정의한 알고리즘의 수행시간을 나타내는 차수는 알고리즘의 효율성에 대한 특성을 파악하고, 여러 알고리즘의 상대적인 성능을 비교할 수 있게 해준다.

알고리즘의 **점근적** 효율성에 관해 학습할 때는 충분히 큰 입력 크기에 대해 수행시간 증가의 차수만 중요하게 취급한다.

대부분의 경우에는 크기가 아주 작은 입력을 제외하면 점근적으로 더 효율적인 알고리즘이 가장 좋은 선택이 될 것이다.

### 점근적 표기
알고리즘의 점근적 수행시간을 나타내는 데 사용하는표기는 정의역이 자연수 집합 N = {0,1,2,...}인 함수들로 정의된다.

이런 표기들은 최악의 경우 수행시간인 함수 T(n)을 나타내기에 편리한데, 보통 정수 입력 크기에 대해서만 정의된다.
#### 점근적 표기, 함수와 수행시간
삽입 정렬의 최악의 경우 수행시간을 쎄타(n^2)로 쓰듯이 점근적 표기는 주로 알고리즘의 수행시간을 나타내기 위해 사용한다.

하지만 점근적 표기는 실제로 함수에 적용된다. 삽입 정렬의 최약의 경우 수행시간을 an^2 + bn + c로 나타낸 것을 상기해보자.

이제 입력에 관계 없이 수행시간을 타나내는 데 알맞은 점근적 표기를 볼 것이다.
### 쎄타-표기
2장에서 삽입 정렬의 최악의 경우 수행시간이 T(n) = 쎄타(n^2)임을 알았다.

주어진 함수 g(n)에 대해 쎄타(g(n))을 다음과 같이 함수들의 집합으로 나타낸다.

O(g(n)) = {f(n) : 모든 n >= n<sub>0</sub>에 대해 0 <= c<sub>1</sub>g(n)<=f(n)<=c<sub>2</sub>g(n)인 양의 상수 c<sub>1</sub>,c<sub>2</sub>,n<sub>0</sub>이 존재한다.}

충분히 큰 n에 대해 f(n)이 c<sub>1</sub>g(n)과 c2g(n)사이에 끼이는 양의 상수 c1, c2가 존재 한다면 f(n)은 집합 쎄타(g(n))에 속한다.

c(1)n^2 <= 1/2n^2-3n <= c(2)n^2

이 식을 n^2으로 나누면 다음과 같다.

c(1) <= 1/2 - 3/n <= c(2)

c(2) >= 1/2인 c(2)를 선택하면 오른쪽의 부등호가 모든 n >= 1값에 대해 성립하게 할 수 있다.

같은 방법으로 c1 <= 1/14인 c(1)을 선택함으로써 왼쪽의 부등호도 모든 n >= 7 값에 대해 성립하게 할 수 있다.

따라서 c(1) = 1/14, c(2) = 1/2, n(0) = 7을 선택하면 1/2n^2 - 3n = 쎄타(n^2)이 됨을 확인할 수 있다.

또한 6n^3 != 쎄타(n^2)임을 확인하기 위해 형식화된 정의를 사용할 수 있다.

정확한 한계를 점근적으로 알아내려 할 때는 큰 n에 대해 점근적으로 양인 함수의 저차항이 무의미하므로 직관적으로 무시할 수 있다.

그러므로 c(1)을 최고차항의 계수보다 조금 작은 값으로, c(2)를 조금 큰 값으로 놓으면 쎄타-표기의 정의에 부등식을 만족한다.

마찬가지로 최고차항의 계수도 무시될 수 있는데, c(1)과 c(2)를 그 계수에 맞추어 바꾸면 된다.

예를 들어, a,b,c 가 상수고 a > 0 인 이차 함수 f(n) = an^2 + bn + c를 생각하면

저차항을 버리고 상수를 무시하면 f(n) = 쎄타(n^2)

