## 삽입 정렬
입력 : n개 수들의 수열 (a<sub>n</sub>)<br>
출력 : 정렬된 수열<br>
정렬하고자 하는 숫자를 <b>키</b>라고 한다.<br>
* 삽입 정렬은 카드놀이를 할 때 손에 쥔 카드를 정렬하는 것과 방법이 같다.
다음은 <b>삽입정렬</b>의 의사코드다.
```
    for j = 2 to A.length
        // key에 A[2..A.length]의 값을 넣는다.
        key = A[j] 
        // i 는 [1..A.length]이다.
        i = j - 1 
        // 반복문은 i가 1보다 크고, key가 A[i]보다 작으면 반복된다.
        while i > 0 & A[i] > key 
            // A[i]를 A[i + 1]에 넣는다.
            A[i + 1] = A[i] 
            // i를 1 빼준다.
            i = i - 1 
        // i를 1 빼줬으니, 1을 더해주고 빈 값에 넣어준다.
        A[i + 1] = key 
```
### 루프 불변성과 삽입 정렬의 타당성
A[1..j-1]는 원래 정렬되있다. 그리고 반복문이 돌 때마다 정렬된다. 그래서 불변성이 참이다.<br>
루프 불변성은 알고리즘이 타당한 이유를 쉽게 이해할 수 있도록 하기 위해 사용된다. 루프 불변성을 보이려면 다음 세 가지 특성을 만족해야 한다.
1. 초기조건: 루프가 첫 번째 반복을 시작하기 전에 루프 불변성이 참이어야 한다.
1. 유지조건: 루프의 반복이 시작되기 전에 루프 불변성이 참이었다면 다음 반복이 시작되기 전까지도 계속 참이어야 한다.
1. 종료조건: 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다.
### 의사코드의 규칙
이 책은 다음과 같은 규칙을 가진다.
* 들여쓰기는 블록 구조를 나타낸다.
* while, for, repeat-until 같은 반복문과 if, then, else 같은 조건문은 C, C++, JAVA, Python과 비슷하게 해석된다.
* //는 주석이다.
* i = j = e 는 j 에 e 가 할당되고 i 에 j 가 할당된다.
* i, j, key 는 변수 선언이다. (type def가 없음)
* 배열의 인덱스는 1부터 시작한다.
* 복합 데이터는 전형적으로 객체 형태로 만들어지며 객체는 필드로 구성된다.
* 프로시저의 매개변수들은 값에 의해 전달된다.
* and와 or같은 이진 논리 연산자는 조기 차단할 수 있다. x and y 면 x가 false면 y는 검사도 안하고 종료됨
### 연습 문제
1. 삽입 정렬을 A = {31, 41, 59, 26, 41, 58} 로 설명하라.
    1. 31
    1. 31 41 (41이 31보다 크니까 반복분이 안돔)
    1. 31 41 59 (위와 같음)
    1. 26 31 41 59 (반복문이 쭉 돌면서 idx 1을 비워두고 반복문이 끝나면 26을 넣는다.)
    1. 26 31 41 41 59 (반복문이 쭉 돌면서 idx 4를 비워두고 반복문이 끝나면 41를 넣음)
    1. 26 31 41 41 58 59 (반복문이 쭉 돌면서 idx 5를 비우고 59를넣음)
2. 내림차순으로 정렬되는 INSERTION-SORT 프로시저를 재작성하라.
```
    for j = 2 to A.length
        // key에 A[2..A.length]의 값을 넣는다.
        key = A[j] 
        // i 는 [1..A.length]이다.
        i = j - 1 
        // 반복문은 i가 1보다 크고, key가 A[i]보다 크면 반복된다.
        while i > 0 & A[i] < key 
            // A[i]를 A[i + 1]에 넣는다.
            A[i + 1] = A[i] 
            // i를 1 빼준다.
            i = i - 1 
        // i를 1 빼줬으니, 1을 더해주고 빈 값에 넣어준다.
        A[i + 1] = key 
```
그냥 while 부분만 바꿔주면 된다.
3. 다음의 검색 문제를 의사코드로 작성해보고 루프의 불변성을 이용해 알고리즘의 타당함을 증명해라
    * 입력 : n개의 수
    * 출력 : v = A[i]를 만족하는 인덱스 i. v가 배열 A에 존재하지 않으면 NIL
```
    // print 초기값을 NIL로 할당한다.
    print = NIL
    // 반복문을 1..A.length 돌린다.
    for 1 to A.length
        // key에 A[i] 즉 A[1..A.length]를 다 넣어본다.
        key = A[i] 
        // key가 v랑 같은지 체크한다.
        if key = v
            // 같으면 print에 key를 넣어주고 반복문을 탈출한다.
            print = key
            break
    // 반복문을 마쳤으니 값을 출력한다.
    출력 print
```
* 초기조건: i = 1 일 때 루프의 불변성이 성립하는지 확인해봤다.
    * A[1]의 값을 if로 체크하고 값을 출력한다.
* 유지조건: 반복할 때 마다 불변성이 성립하는지 확인해봤다.
    * A[1..A.length]의 값을 if문으로 다 체크해주기 때문에 루프의 불변성은 유지된다.
* 종료조건: 루프가 종료할 때 루프의 불변성이 성립하는지 확인해봤다.
    * print에 초기값은 NIL인데, 반복문을 돌면서 값을 찾았을 수 있고, 그 값을 찾았다면 print에 그 값을 할당하기 때문에
알고리즘은 타당하다. ㅋ
4. 원소가 n개인 두 배열 A, B에 저장된 두 개의 n비트 이진수를 더하는 문제를 고려해보자. 두 이진수의 합은 원소가 n + 1개인 배열 C에 이진수 형태로 저장되어야 한다.
```
    // C배열의 초기값은 0이다.
    C[1..n+1] = 0
    // 1부터 n까지 반복문을 돈다.
    for i = 1 to n
        // A[i]가 1이고 B가 1이면
        if A[i] = 1 & B[i] = 1
            // C[i + 1]을 1로 만들어준다.
            C[i + 1] = 1
        // A[i], B[i]가 둘중 하나라도 1이 아니면
        else
            // C[i]에 A[i] + B[i]의 값을 더해준다.
            // 더하는 이유는 그 전의 값이 1 1 이여서 1로 세팅됐을 수 있다.
            C[i] += A[i] + B[i]
        // i - 1 일 때 A[i], B[i]가 둘다 1이고,
        // 지금 A[i], B[i] 둘중 하나가 1일 때
        if C[i] > 1
            // C[i + 1]값에 1로 만들어 준다.
            C[i + 1] = 1
            // C[i]는 0으로 만들어준다.
            C[i] = 0
```
* 한번 알고리즘이 타당한지 확인해보자.
    * A = {1}, B = {1} : C = {0, 1}
    * A = {0}, B = {1} : C = {1, 0}
    * A = {1}, B = {0} : C = {1, 0}
    * A = {1, 1}, B = {1, 1} : C = {0, 1, 1}
    * A = {0, 1}, B = {1, 1} : C = {0, 0, 1}
    * A = {1, 1}, B = {0, 1} : C = {0, 0, 1}
    * A = {0, 1}, B = {0, 1} : C = {0, 0, 1}
* 초기조건, 유지조건, 종료조건 다 성립한다.