MERGE 프로시저를 정렬 알고리즘의 서브 루틴으로 이용한다.
```
MERGE-SORT(A, p, r)
1   if q < r
2       q = (p + r) / 2
3       MERGE-SORT(A, p, q)
4       MERGE-SORT(A, q+1, r)
5       MERGE(A, p, q, r)
```
전체 수열을 정리하려면 MERGE-SORT(A, 1, A.length)를 하면 된다.<br>
### 분할정복 알고리즘의 분석
알고리즘이 자기 자신을 호출하는 재귀 호출을 할 경우 수행시간을 **재귀 방저식**또는 **점화식**으로 설명할 수 있다.<br>
## 병합 정렬의 분석
MERGE-SORT 의사코드는 원소의 개수가 짝수가 아닐 때도 올바르게 동작하지만, 문제 크기를 2의 거듭제곱으로 가정하면 점화식에 대한 분석을 단순화할 수 있다.<br>
* 분할: 분할 단계는 부분 배열의 중간 위치를 계산하므로 상수 시간이 걸린다. 즉, D(n) = 쎄타1 이다.
* 정복: 두 개의 부분 문제를 재귀적으로 푸는데, 각 부분 문제는 크기가 n/2이므로 2T(n/2)수행시간이 걸린다.
* 결합: n개 원소에 대해 MERGE프로시저는 쎄타n 시간이 걸린다. C(n) = 쎄타n이다.
```
T(n) = 쎄타n              if n = 1
       2T(n/2) + 쎄타n    if n > 1
```
T(n) = 쎄타nlgn이며, nlgn은 log<sub>2</sub>n을 나타낸다.
### 연습문제
1. A = {3, 41, 52 ,26 ,38, 57, 9, 49}를 병합 정렬로 설명해라.
* {3, 41, 52, 26} {38, 57, 9, 49}
* {3, 41} {52, 26} {38, 57} {9, 49}
* {3, 41} {26, 52} {38, 57} {9, 49}
* {3, 26, 41, 52} {9, 38, 49, 57}
* {3, 9, 26, 38, 41, 48, 52, 57}
* 원래는 더 나눠지는데, 귀찮아서 이정도만..
2. MERGE프로시저를 경계값을 사용하지 않고 모두 복사하면 비굦가업을 끝내고 나머지 배열에서 복사되지 않고 남은 원소를 A에 모두 복사하도록 작성해라.
```
MERGE(A, p, q, r)
a = q - p + 1
b = r - q
L[1..a], R[1..b]
for i = 1 to a
    L[i] = A[p + i - 1]
for i = 1 to b
    R[i] = A[q + i]
j = i = 1
for k = p to r 
    if j = r or L[i] <= R[j]
        A[k] = L[i]
        i = i + 1
    else
        A[k] = R[j]
        j = j + 1
```
3. n이 2의 거듭제곱일 때 수학적 귀납법을 이용해 다음 점화식의 해사 T(n) = nlgn임을 보여라.
```
T(n) = 2            if n = 2
       2T(n/2) + n  if n = 2 pow k, for k > 1
```
* T(n)이 2일 땐, 2니까 초기조건 성공
* 2가 아니면 T2개에 n의 반값을 넣는다. 계산을 위해 8로 실험을 해보자
    * T(n) = 8 + 2T(4)
        * T(n) = 4 + 2T(2)
            * T(n) = 2
            * T(n) = 2
        * T(n) = 4 + 2T(2)
            * T(n) = 2
            * T(n) = 2
    * 그러면 8 + 4 * 2 + 2 * 4 = (8 + 8 + 8) = nlgn (8 * 3)
4. 삽입 정렬을 재귀호출로 만들고, 최악의 경우 수행시간에 관한 점화식을 써라.
```
INSERTION-SORT(A)
if n > 1
    while i = 2 to A.length
        INSERTION(A, i)
INSERTION(A, i)
j = i - 1
while j > 0 & A[j] > num
    A[j + 1] = A[j]
    j--
A[j] = A[i]

T(n) = 1                    if n = 1
       (n-1)*(i-1)
```
5. 이진 검색이 최악의 경우 쎄타lgn임을 증명하라
* 숫자가 {1, 2, 3, 4, 5, 6, 7, 8}
* 찾으려는 숫자 9
    * [4]=4 l=1 r=8 m=4
    * [6]=6 l=5 r=8 m=6=(5+8)/2
    * [7]=7 l=7 r=8 m=7=(7+8)/2
    * [8]=8 l=8 r=8 m=8=(8+8)/2
* lgn + 1인데 쎄타표기 법 이니 lgn이다.
6. 삽입 정렬에 이진 검색을 넣으면 nlgn이 되나?
* 자리를 바꾸는게 너무많아서 n<sup>2</sup>가 된다.
7. n개 정수의 집합 S와 정수 x가 주어졌을 때, S에 있는 두 원소의 합이 x가 되는 경우가 있는지 알아내는 쎄타nlgn시간 알고리즘을 구해라.
```
dp[][]로 풀어야됨.
```