## 알고리즘의 분석
알고리즘의 <b>분석</b>은 그 알고리즘을 실행하는 데 필요한 자원을 예측하는 것을 의미한다.<br>
메모리, 통신 대역, 하드웨어 같은 자원이 주요 관심 대상이 되기도 하지만 대부분의 경우에 측정 대상은 계산 시간이다.<br>
알고리즘을 분서하기에 앞서 이용할 구현 기술의 모델을 잘 정의해야 하는데, 여기에는 그 기술에 필요한 자원과 비용에 관한 모델도 포함된다.<br>
알고리즘이 단일 프로세서와 <b>랜덤 접근 기계(RAM, random-access machine)</b> 모델에서 컴퓨터 프로그램으로 구현된다고 가정한다. RAM에서는 명령어를 차례대로 실행한다.(동시 실행은 안함)<br>
### 삽입 정렬의 분석
INSERTION-SORT의 수행시간은 입력에 의해 결정된다.<br>
<b>입력 크기</b>에 대한 가장 정확한 개념은 주어진 문제에 따라 다르다.<br>
<b>수행시간</b>은 기본 연산 개수 또는 실행된 "단계"의 횟수를 말한다.<br>
INSERTION-SORT 프로시저를 각 명령문의 실해에 따른 시간"비용"과 실행 횟수를 고려해 살펴본다.<br>
```
    for j = 2 to A.length               c1  n
        key = A[j]                      c2  n-1
        i = j - 1                       c3  n-1
        while i > 0 and A[i] > key      c4  j=2 to n * tj
            A[i + 1] = A[i]             c5  j=2 to n * (tj - 1)
            i = i - 1                   c6  j=2 to n * (tj - 1)
        A[i + 1] = key                  c7  n-1
```
T(n) = c<sub>1</sub>n + c<sub>2</sub>(n - 1) + c<sub>3</sub>(n - 1) + c<sub>4</sub>t<sub>j</sub> + c<sub>5</sub>(t<sub>j</sub> - 1) + c<sub>6</sub>(t<sub>j</sub> - 1) + c<sub>7</sub>(n - 1)<br>
최선의 상황 (t<sub>j</sub>가 1일 경우) : (c1 + c2 + c3 + c4 + c7)n - (c2 + c4 + c5 + c8) [n에 관한 선형함수]<br>
최악의 상황에는 (j=2 to n) 이 (n(n + 1) / 2 -1) 이것이 된다.<br>
최악의 상황 : ((c4 + c5 + c6) / 2)n<sup>2</sup> + (c1 + c2 + c3 + (c4 - c6 - c7) / 2 + c8)n - (c2 + c3 +c5 + c7)<br>
수행 시간 : n에 관한 이차식<br>
### 최악의 경우와 평균적인 경우의 분석
삽입 정렬을 분석하면서 입력 배열이 이미 정렬된 최선의 경우와 입력 배열이 역순으로 정렬된 최악의 경우를 살펴보았다.<br>
이 책은 최악의 경우 수행시간에 주로 관심을 가진다.
* 알고리즘에서 최악의 경우로 수행시간을 체크하면 최대 얼만큼 걸리는지 알 수 있다.
* 어떤 알고리즘은 최악의 경우가 상당히 빈번히 발생할 수 있다.
* 평균적인 경우가 최악의 경우만큼 거의 좋지 못한 상황일 때가 종종 있다.
반면, 어떤 경우는 <b>평균 수행시간</b>이 중요하다.
### 증가 차수
쎄타 n제곱 이라고 한다.
### 연습 문제
1. n<sup>3</sup> / 1000 - 100n<sup>2</sup> - 100n + 3 을 쎄타 표기법으로 나타내라.
* 쎄타 n 3제곱
2. 배열 A에 저장된 n개의 수를 정렬하는 알고리즘을 고려해보자 <b>선택정렬</b>사용하고, 루프의 불변성을 유지하는지 설명해라 그리고 최선의 방법과 최악의 방법을 쎄타 표기법으로 표기해라
```
    for i = 1 to A.length - 1
        minidx = i
        for j = i + 1 to A.length
            if A[i] > A[j]
                temp = A[i]
                A[i] = A[j]
                A[j] = temp
```
* 루프의 불변성 확인
    * 초기조건 : A의 length가 1이면 정렬 돼있는거니 참
    * 유지조건 : 반복문이 돌 때 순서대로 값이 잘 정렬되니 참
    * 종료조건 : 반복문은 A.length - 1 까지 돌고, A.length - 1 까지 하는 이유는 안에있는 작은 순서대로 정렬되는거라 마지막에는 큰 수가 들어갈 수 밖에 없다. 잘 된다. 참
* 최선의 상황 : 쎄타 n 제곱 
* 최악의 상황 : 쎄타 n 제곱
* 최악의 상황과 최선의 상황이 같은 이유는 반복문은 따로 조건이 없어서 무조건 돌기 때문.(어디에 무슨값이 있을지 모름)
3. 선형 검색을 다시 생각해보자 최선의 상황과 최악의 상황을 쎄타 표기법으로 표기해라
* 최선의 상황 : 쎄타 1
* 최악의 상황 : 쎄타 n
4. 최선의 경우에 알고리즘이 좋은 수행시간을 갖게 하려면 어떻게 바꿔야 하는가?
* 반복문을 탈출한다.